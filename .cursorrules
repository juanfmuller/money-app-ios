# Money App iOS - Cursor Development Rules

## ğŸ¯ Development Guidelines

This iOS codebase follows modern MVVM architecture with **Swift 6 Observation**, **actor-based concurrency**, and **simple navigation patterns**. **Always follow these rules when making changes.**

## ğŸ“ Detailed Rules Documentation

For comprehensive guidelines, refer to these specific rule files:

### ğŸ—ï¸ [Architecture Rules](.cursor/rules/architecture.md)
- Feature-based code organization (mirrors backend structure)
- MVVM pattern with Swift 6 @Observable (no @ObservableObject/@Published)
- Actor-based services with protocol injection
- Modern Swift concurrency (async/await + Sendable)
- No caching strategy (polling-based)
- Separation of concerns (Views â†’ ViewModels â†’ Services â†’ Models)
- Adding new features workflow

### ğŸ§­ [Navigation Rules](.cursor/rules/navigation.md)
- Simple centralized AppRouter for MVP navigation
- NavigationStack with enum-based routing
- Environment-based router injection
- Feature view factories for quick "glueing"
- Sheet and fullScreenCover presentation patterns

### ğŸ§ª [Testing Rules](.cursor/rules/testing.md)
- Unit testing for ViewModels and Services
- UI testing with SwiftUI
- Test organization by feature
- Mock patterns for API services
- TDD workflow patterns

### âš ï¸ [Development Workflow](.cursor/rules/development-workflow.md)
- **MANDATORY**: Build and run tests after every Swift file change
- Git workflow and commit requirements
- Test execution guidelines
- Failure response protocols

### ğŸš¨ [Error Handling](.cursor/rules/error-handling.md)
- Standardized error response handling
- Custom error types for API responses
- User-friendly error messages
- Logging patterns and security

### ğŸ”— [API Integration](.cursor/rules/api-integration.md)
- RESTful client conventions
- Request/response model patterns
- JWT token management
- Polling strategies and optimization

### ğŸ” [Security Rules](.cursor/rules/security.md)
- JWT token storage and management
- Keychain integration
- API security best practices
- Push notification token handling

## âš¡ Quick Start Checklist

### Before Making ANY Changes:
1. âœ… Read the relevant rule files above
2. âœ… Understand the feature-based MVVM architecture
3. âœ… Build project and run tests to ensure they pass

### When Adding New Features:
1. âœ… Create feature directory: `MoneyApp/Features/NewFeature/`
2. âœ… Follow the 4-layer pattern: `Views/`, `ViewModels/`, `Models/`, `Services/`
3. âœ… Write tests FIRST: unit tests for ViewModels and Services
4. âœ… Use Codable for all API contracts
5. âœ… Implement proper async/await patterns

### After Making Changes:
1. âœ… **MANDATORY**: Build project (Cmd+B) and run tests (Cmd+U)
2. âœ… Verify no SwiftUI preview errors
3. âœ… Check API responses match Codable models
4. âœ… Test polling behavior in simulator

## ğŸš« Never Do These Things:

- âŒ **Never commit without building and testing**
- âŒ Never mix business logic in SwiftUI Views
- âŒ Never cache API responses (use polling only)
- âŒ Never hardcode API endpoints or secrets
- âŒ Never ignore compiler warnings
- âŒ Never use force unwrapping without explicit safety
- âŒ Never organize code by technical layer (all views/, all models/, etc.)

## âœ… Always Do These Things:

- âœ… **Always build and test after changing Swift files**
- âœ… Always use @Observable for ViewModels (not @ObservableObject)
- âœ… Always use @State for ViewModel ownership (not @StateObject)
- âœ… Always use actors for services with protocol injection
- âœ… Always delegate API calls to Services
- âœ… Always use async/await for networking with Sendable protocols
- âœ… Always handle errors gracefully
- âœ… Always validate with Codable models
- âœ… Always organize by feature domain
- âœ… Always use AppRouter for navigation

## ğŸª Architecture Quick Reference

```
MoneyApp/
â”œâ”€â”€ Features/                  # â† Organize by business domain (mirrors backend)
â”‚   â”œâ”€â”€ Auth/                 # Authentication feature
â”‚   â”‚   â”œâ”€â”€ Views/            # SwiftUI views only
â”‚   â”‚   â”œâ”€â”€ ViewModels/       # @ObservableObject business logic
â”‚   â”‚   â”œâ”€â”€ Models/           # Codable models
â”‚   â”‚   â””â”€â”€ Services/         # API calls and networking
â”‚   â”œâ”€â”€ Accounts/             # Account management
â”‚   â”œâ”€â”€ Transactions/         # Transaction handling
â”‚   â””â”€â”€ Notifications/        # Push notifications
â”œâ”€â”€ Shared/                   # Cross-feature components
â”‚   â”œâ”€â”€ Models/              # Common Codable models
â”‚   â”œâ”€â”€ Views/               # Reusable SwiftUI components
â”‚   â””â”€â”€ Services/            # Shared networking utilities
â”œâ”€â”€ Core/                    # Infrastructure
â”‚   â”œâ”€â”€ Networking/          # Base API client
â”‚   â”œâ”€â”€ Security/            # JWT & Keychain utilities
â”‚   â””â”€â”€ Configuration/       # App settings
â””â”€â”€ Resources/               # Assets, strings, etc.
```

## ğŸ§ª Testing Quick Reference

```bash
# Essential commands (run after EVERY Swift file change)
# In Xcode:
Cmd+B                           # Build - must succeed
Cmd+U                           # Run all tests - must pass
Cmd+Shift+K                     # Clean build folder

# Feature-specific testing
# Use Test Navigator to run specific test targets:
AuthTests                       # Authentication tests
AccountsTests                   # Account management tests
TransactionsTests               # Transaction handling tests
```

## ğŸ”— MVVM Pattern Quick Reference (Swift 6)

```swift
// View Layer (SwiftUI) - UI concerns only
struct LoginView: View {
    @State private var viewModel = LoginViewModel()  // â† @State, not @StateObject
    @Environment(AppRouter.self) private var router
    
    var body: some View {
        VStack {
            TextField("Email", text: $viewModel.email)
            SecureField("Password", text: $viewModel.password)
            Button("Login") {
                Task { await viewModel.login() }  // â† Delegate to ViewModel
            }
        }
        .alert("Error", isPresented: $viewModel.showError) {
            Button("OK") { }
        } message: {
            Text(viewModel.errorMessage)  // â† ViewModel handles errors
        }
        .onAppear {
            viewModel.router = router  // â† Inject router
        }
    }
}

// ViewModel Layer (@Observable) - Business logic only
@Observable
@MainActor
class LoginViewModel {
    var email = ""  // â† No @Published needed
    var password = ""
    var isLoading = false
    var showError = false
    var errorMessage = ""
    var router: AppRouter?
    
    private let authService: AuthServiceProtocol
    
    init(authService: AuthServiceProtocol = AuthService()) {
        self.authService = authService
    }
    
    func login() async {
        isLoading = true
        do {
            let request = LoginRequest(email: email, password: password)
            let response = try await authService.login(request)  // â† Delegate to Service
            router?.navigateToMain()  // â† Use router for navigation
        } catch {
            handleError(error)  // â† Proper error handling
        }
        isLoading = false
    }
}

// Service Layer - Actor with protocol injection
protocol AuthServiceProtocol: Sendable {
    func login(_ request: LoginRequest) async throws -> AuthResponse
}

actor AuthService: AuthServiceProtocol {
    private let apiClient: APIClientProtocol
    
    init(apiClient: APIClientProtocol = APIClient.shared) {
        self.apiClient = apiClient
    }
    
    func login(_ request: LoginRequest) async throws -> AuthResponse {
        return try await apiClient.post("/api/auth/login", body: request)
    }
}

// Model Layer (Codable) - Data contracts
struct LoginRequest: Codable {
    let email: String
    let password: String
}

struct AuthResponse: Codable {
    let accessToken: String
    let user: User
}
```

## ğŸ“‹ Code Review Checklist

When reviewing or writing code, ensure:

### Architecture âœ…
- [ ] Code is organized by feature, not layer
- [ ] Views only handle UI concerns
- [ ] Business logic is in ViewModels
- [ ] API calls are in Services with actors
- [ ] Codable models define API contracts
- [ ] Navigation uses AppRouter

### SwiftUI & Concurrency âœ…
- [ ] Views use @State for ViewModels (not @StateObject)
- [ ] ViewModels use @Observable (not @ObservableObject)
- [ ] ViewModels are @MainActor classes
- [ ] Services are actors with Sendable protocols
- [ ] Async operations use async/await
- [ ] Proper Task { } usage in views
- [ ] No force unwrapping without safety

### Testing âœ…
- [ ] Unit tests for ViewModel methods
- [ ] Unit tests for Service methods
- [ ] UI tests for critical user flows
- [ ] Mock services for testing
- [ ] All tests pass with good coverage

### Security âœ…
- [ ] No hardcoded secrets
- [ ] JWT tokens stored securely
- [ ] API client uses proper authentication
- [ ] No sensitive data in logs

### Error Handling âœ…
- [ ] Specific error types for API responses
- [ ] User-friendly error messages
- [ ] Graceful degradation on failures
- [ ] Proper async error propagation

## ğŸ¯ API Integration Patterns

### Polling Strategy (No Caching) - Swift 6 Style
```swift
@Observable
@MainActor
class TransactionViewModel {
    var transactions: [Transaction] = []
    var isPolling = false
    
    private let transactionService: TransactionServiceProtocol
    private var pollingTask: Task<Void, Never>?
    
    init(transactionService: TransactionServiceProtocol = TransactionService()) {
        self.transactionService = transactionService
    }
    
    func startPolling() {
        guard !isPolling else { return }
        isPolling = true
        
        pollingTask = Task {
            while !Task.isCancelled {
                await refreshTransactions()
                try? await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds
            }
        }
    }
    
    func stopPolling() {
        pollingTask?.cancel()
        pollingTask = nil
        isPolling = false
    }
    
    private func refreshTransactions() async {
        do {
            transactions = try await transactionService.getRecent()
        } catch {
            // Handle polling errors gracefully
        }
    }
}
```

### JWT Token Management - Actor Pattern
```swift
protocol TokenManagerProtocol: Sendable {
    func getAccessToken() async -> String?
    func saveTokens(accessToken: String, refreshToken: String?) async
    func clearTokens() async
}

actor TokenManager: TokenManagerProtocol {
    private let keychainService: KeychainServiceProtocol
    
    init(keychainService: KeychainServiceProtocol = KeychainService.shared) {
        self.keychainService = keychainService
    }
    
    func getAccessToken() async -> String? {
        return await keychainService.getToken(for: "access_token")
    }
    
    func saveTokens(accessToken: String, refreshToken: String?) async {
        await keychainService.save(accessToken, for: "access_token")
        if let refreshToken = refreshToken {
            await keychainService.save(refreshToken, for: "refresh_token")
        }
    }
    
    func clearTokens() async {
        await keychainService.delete("access_token")
        await keychainService.delete("refresh_token")
    }
}
```

## ğŸš€ Backend Integration Reference

The iOS app integrates with these backend endpoints:

### Authentication
- `POST /api/auth/register` â†’ `AuthService.register()`
- `POST /api/auth/login` â†’ `AuthService.login()`
- `POST /api/auth/device-token` â†’ `AuthService.updateDeviceToken()`

### Accounts
- `POST /api/accounts/link/token` â†’ `AccountService.createLinkToken()`
- `POST /api/accounts/link/exchange` â†’ `AccountService.linkAccount()`
- `GET /api/accounts/` â†’ `AccountService.getAccounts()`
- `GET /api/accounts/sync/status` â†’ `AccountService.getSyncStatus()` (polling)

### Transactions
- `GET /api/transactions/recent` â†’ `TransactionService.getRecent()` (polling)
- `GET /api/transactions/` â†’ `TransactionService.getTransactions()`
- `GET /api/transactions/summary` â†’ `TransactionService.getSummary()`

### Notifications
- `POST /api/notifications/test` â†’ `NotificationService.sendTest()`

## ğŸª Remember

This modern architecture enables:
- **ğŸš€ Fast development**: Swift 6 @Observable reduces boilerplate significantly
- **ğŸ”§ Easy maintenance**: Actor-based services prevent race conditions
- **ğŸ‘¥ Team collaboration**: Protocol injection makes testing effortless
- **ğŸ¯ Quality assurance**: Tests catch regressions automatically
- **ğŸ“ˆ Scalability**: Add features without affecting existing code
- **âš¡ Real-time updates**: Efficient polling keeps data fresh
- **ğŸ§­ Simple navigation**: AppRouter pattern allows quick feature "glueing"

**Every Swift file change requires building and testing. No exceptions.** ğŸ§ª

## ğŸ†˜ Need Help?

1. ğŸ“– **Read the specific rule files** in `.cursor/rules/`
2. ğŸ” **Look at existing features** for patterns to follow
3. ğŸ—ï¸ **Mirror the backend structure** for consistency
4. ğŸ§ª **Build and test early and often** to catch issues quickly
5. ğŸª **Follow the established MVVM patterns** for consistency