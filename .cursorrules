# Money App iOS - Cursor Development Rules

## 🎯 Development Guidelines

This iOS codebase follows modern MVVM architecture with **Swift 6 Observation**, **actor-based concurrency**, and **simple navigation patterns**. **Always follow these rules when making changes.**

## 📁 Detailed Rules Documentation

For comprehensive guidelines, refer to these specific rule files:

### 🏗️ [Architecture Rules](.cursor/rules/architecture.md)
- Feature-based code organization (mirrors backend structure)
- MVVM pattern with Swift 6 @Observable (no @ObservableObject/@Published)
- Actor-based services with protocol injection
- Modern Swift concurrency (async/await + Sendable)
- No caching strategy (polling-based)
- Separation of concerns (Views → ViewModels → Services → Models)
- Adding new features workflow

### 🧭 [Navigation Rules](.cursor/rules/navigation.md)
- Simple centralized AppRouter for MVP navigation
- NavigationStack with enum-based routing
- Environment-based router injection
- Feature view factories for quick "glueing"
- Sheet and fullScreenCover presentation patterns

### 🧪 [Testing Rules](.cursor/rules/testing.md)
- Unit testing for ViewModels and Services
- UI testing with SwiftUI
- Test organization by feature
- Mock patterns for API services
- TDD workflow patterns

### ⚠️ [Development Workflow](.cursor/rules/development-workflow.md)
- **MANDATORY**: Build and run tests after every Swift file change
- Git workflow and commit requirements
- Test execution guidelines
- Failure response protocols

### 🚨 [Error Handling](.cursor/rules/error-handling.md)
- Standardized error response handling
- Custom error types for API responses
- User-friendly error messages
- Logging patterns and security

### 🔗 [API Integration](.cursor/rules/api-integration.md)
- RESTful client conventions
- Request/response model patterns
- JWT token management
- Polling strategies and optimization

### 🔐 [Security Rules](.cursor/rules/security.md)
- JWT token storage and management
- Keychain integration
- API security best practices
- Push notification token handling

## ⚡ Quick Start Checklist

### Before Making ANY Changes:
1. ✅ Read the relevant rule files above
2. ✅ Understand the feature-based MVVM architecture
3. ✅ Build project and run tests to ensure they pass

### When Adding New Features:
1. ✅ Create feature directory: `MoneyApp/Features/NewFeature/`
2. ✅ Follow the 4-layer pattern: `Views/`, `ViewModels/`, `Models/`, `Services/`
3. ✅ Write tests FIRST: unit tests for ViewModels and Services
4. ✅ Use Codable for all API contracts
5. ✅ Implement proper async/await patterns

### After Making Changes:
1. ✅ **MANDATORY**: Build project (Cmd+B) and run tests (Cmd+U)
2. ✅ Verify no SwiftUI preview errors
3. ✅ Check API responses match Codable models
4. ✅ Test polling behavior in simulator

## 🚫 Never Do These Things:

- ❌ **Never commit without building and testing**
- ❌ Never mix business logic in SwiftUI Views
- ❌ Never cache API responses (use polling only)
- ❌ Never hardcode API endpoints or secrets
- ❌ Never ignore compiler warnings
- ❌ Never use force unwrapping without explicit safety
- ❌ Never organize code by technical layer (all views/, all models/, etc.)

## ✅ Always Do These Things:

- ✅ **Always build and test after changing Swift files**
- ✅ Always use @Observable for ViewModels (not @ObservableObject)
- ✅ Always use @State for ViewModel ownership (not @StateObject)
- ✅ Always use actors for services with protocol injection
- ✅ Always delegate API calls to Services
- ✅ Always use async/await for networking with Sendable protocols
- ✅ Always handle errors gracefully
- ✅ Always validate with Codable models
- ✅ Always organize by feature domain
- ✅ Always use AppRouter for navigation

## 🎪 Architecture Quick Reference

```
MoneyApp/
├── Features/                  # ← Organize by business domain (mirrors backend)
│   ├── Auth/                 # Authentication feature
│   │   ├── Views/            # SwiftUI views only
│   │   ├── ViewModels/       # @ObservableObject business logic
│   │   ├── Models/           # Codable models
│   │   └── Services/         # API calls and networking
│   ├── Accounts/             # Account management
│   ├── Transactions/         # Transaction handling
│   └── Notifications/        # Push notifications
├── Shared/                   # Cross-feature components
│   ├── Models/              # Common Codable models
│   ├── Views/               # Reusable SwiftUI components
│   └── Services/            # Shared networking utilities
├── Core/                    # Infrastructure
│   ├── Networking/          # Base API client
│   ├── Security/            # JWT & Keychain utilities
│   └── Configuration/       # App settings
└── Resources/               # Assets, strings, etc.
```

## 🧪 Testing Quick Reference

```bash
# Essential commands (run after EVERY Swift file change)
# In Xcode:
Cmd+B                           # Build - must succeed
Cmd+U                           # Run all tests - must pass
Cmd+Shift+K                     # Clean build folder

# Feature-specific testing
# Use Test Navigator to run specific test targets:
AuthTests                       # Authentication tests
AccountsTests                   # Account management tests
TransactionsTests               # Transaction handling tests
```

## 🔗 MVVM Pattern Quick Reference (Swift 6)

```swift
// View Layer (SwiftUI) - UI concerns only
struct LoginView: View {
    @State private var viewModel = LoginViewModel()  // ← @State, not @StateObject
    @Environment(AppRouter.self) private var router
    
    var body: some View {
        VStack {
            TextField("Email", text: $viewModel.email)
            SecureField("Password", text: $viewModel.password)
            Button("Login") {
                Task { await viewModel.login() }  // ← Delegate to ViewModel
            }
        }
        .alert("Error", isPresented: $viewModel.showError) {
            Button("OK") { }
        } message: {
            Text(viewModel.errorMessage)  // ← ViewModel handles errors
        }
        .onAppear {
            viewModel.router = router  // ← Inject router
        }
    }
}

// ViewModel Layer (@Observable) - Business logic only
@Observable
@MainActor
class LoginViewModel {
    var email = ""  // ← No @Published needed
    var password = ""
    var isLoading = false
    var showError = false
    var errorMessage = ""
    var router: AppRouter?
    
    private let authService: AuthServiceProtocol
    
    init(authService: AuthServiceProtocol = AuthService()) {
        self.authService = authService
    }
    
    func login() async {
        isLoading = true
        do {
            let request = LoginRequest(email: email, password: password)
            let response = try await authService.login(request)  // ← Delegate to Service
            router?.navigateToMain()  // ← Use router for navigation
        } catch {
            handleError(error)  // ← Proper error handling
        }
        isLoading = false
    }
}

// Service Layer - Actor with protocol injection
protocol AuthServiceProtocol: Sendable {
    func login(_ request: LoginRequest) async throws -> AuthResponse
}

actor AuthService: AuthServiceProtocol {
    private let apiClient: APIClientProtocol
    
    init(apiClient: APIClientProtocol = APIClient.shared) {
        self.apiClient = apiClient
    }
    
    func login(_ request: LoginRequest) async throws -> AuthResponse {
        return try await apiClient.post("/api/auth/login", body: request)
    }
}

// Model Layer (Codable) - Data contracts
struct LoginRequest: Codable {
    let email: String
    let password: String
}

struct AuthResponse: Codable {
    let accessToken: String
    let user: User
}
```

## 📋 Code Review Checklist

When reviewing or writing code, ensure:

### Architecture ✅
- [ ] Code is organized by feature, not layer
- [ ] Views only handle UI concerns
- [ ] Business logic is in ViewModels
- [ ] API calls are in Services with actors
- [ ] Codable models define API contracts
- [ ] Navigation uses AppRouter

### SwiftUI & Concurrency ✅
- [ ] Views use @State for ViewModels (not @StateObject)
- [ ] ViewModels use @Observable (not @ObservableObject)
- [ ] ViewModels are @MainActor classes
- [ ] Services are actors with Sendable protocols
- [ ] Async operations use async/await
- [ ] Proper Task { } usage in views
- [ ] No force unwrapping without safety

### Testing ✅
- [ ] Unit tests for ViewModel methods
- [ ] Unit tests for Service methods
- [ ] UI tests for critical user flows
- [ ] Mock services for testing
- [ ] All tests pass with good coverage

### Security ✅
- [ ] No hardcoded secrets
- [ ] JWT tokens stored securely
- [ ] API client uses proper authentication
- [ ] No sensitive data in logs

### Error Handling ✅
- [ ] Specific error types for API responses
- [ ] User-friendly error messages
- [ ] Graceful degradation on failures
- [ ] Proper async error propagation

## 🎯 API Integration Patterns

### Polling Strategy (No Caching) - Swift 6 Style
```swift
@Observable
@MainActor
class TransactionViewModel {
    var transactions: [Transaction] = []
    var isPolling = false
    
    private let transactionService: TransactionServiceProtocol
    private var pollingTask: Task<Void, Never>?
    
    init(transactionService: TransactionServiceProtocol = TransactionService()) {
        self.transactionService = transactionService
    }
    
    func startPolling() {
        guard !isPolling else { return }
        isPolling = true
        
        pollingTask = Task {
            while !Task.isCancelled {
                await refreshTransactions()
                try? await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds
            }
        }
    }
    
    func stopPolling() {
        pollingTask?.cancel()
        pollingTask = nil
        isPolling = false
    }
    
    private func refreshTransactions() async {
        do {
            transactions = try await transactionService.getRecent()
        } catch {
            // Handle polling errors gracefully
        }
    }
}
```

### JWT Token Management - Actor Pattern
```swift
protocol TokenManagerProtocol: Sendable {
    func getAccessToken() async -> String?
    func saveTokens(accessToken: String, refreshToken: String?) async
    func clearTokens() async
}

actor TokenManager: TokenManagerProtocol {
    private let keychainService: KeychainServiceProtocol
    
    init(keychainService: KeychainServiceProtocol = KeychainService.shared) {
        self.keychainService = keychainService
    }
    
    func getAccessToken() async -> String? {
        return await keychainService.getToken(for: "access_token")
    }
    
    func saveTokens(accessToken: String, refreshToken: String?) async {
        await keychainService.save(accessToken, for: "access_token")
        if let refreshToken = refreshToken {
            await keychainService.save(refreshToken, for: "refresh_token")
        }
    }
    
    func clearTokens() async {
        await keychainService.delete("access_token")
        await keychainService.delete("refresh_token")
    }
}
```

## 🚀 Backend Integration Reference

The iOS app integrates with these backend endpoints:

### Authentication
- `POST /api/auth/register` → `AuthService.register()`
- `POST /api/auth/login` → `AuthService.login()`
- `POST /api/auth/device-token` → `AuthService.updateDeviceToken()`

### Accounts
- `POST /api/accounts/link/token` → `AccountService.createLinkToken()`
- `POST /api/accounts/link/exchange` → `AccountService.linkAccount()`
- `GET /api/accounts/` → `AccountService.getAccounts()`
- `GET /api/accounts/sync/status` → `AccountService.getSyncStatus()` (polling)

### Transactions
- `GET /api/transactions/recent` → `TransactionService.getRecent()` (polling)
- `GET /api/transactions/` → `TransactionService.getTransactions()`
- `GET /api/transactions/summary` → `TransactionService.getSummary()`

### Notifications
- `POST /api/notifications/test` → `NotificationService.sendTest()`

## 🎪 Remember

This modern architecture enables:
- **🚀 Fast development**: Swift 6 @Observable reduces boilerplate significantly
- **🔧 Easy maintenance**: Actor-based services prevent race conditions
- **👥 Team collaboration**: Protocol injection makes testing effortless
- **🎯 Quality assurance**: Tests catch regressions automatically
- **📈 Scalability**: Add features without affecting existing code
- **⚡ Real-time updates**: Efficient polling keeps data fresh
- **🧭 Simple navigation**: AppRouter pattern allows quick feature "glueing"

**Every Swift file change requires building and testing. No exceptions.** 🧪

## 🆘 Need Help?

1. 📖 **Read the specific rule files** in `.cursor/rules/`
2. 🔍 **Look at existing features** for patterns to follow
3. 🏗️ **Mirror the backend structure** for consistency
4. 🧪 **Build and test early and often** to catch issues quickly
5. 🎪 **Follow the established MVVM patterns** for consistency