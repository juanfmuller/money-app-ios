# Money App iOS - Cursor Development Rules

## ğŸ¯ Development Guidelines

This iOS codebase follows strict MVVM architecture patterns with modern SwiftUI and Swift concurrency. **Always follow these rules when making changes.**

## ğŸ“ Detailed Rules Documentation

For comprehensive guidelines, refer to these specific rule files:

### ğŸ—ï¸ [Architecture Rules](.cursor/rules/architecture.md)
- Feature-based code organization (mirrors backend structure)
- MVVM pattern with SwiftUI
- Modern Swift concurrency (async/await)
- No caching strategy (polling-based)
- Separation of concerns (Views â†’ ViewModels â†’ Services â†’ Models)
- Adding new features workflow

### ğŸ§ª [Testing Rules](.cursor/rules/testing.md)
- Unit testing for ViewModels and Services
- UI testing with SwiftUI
- Test organization by feature
- Mock patterns for API services
- TDD workflow patterns

### âš ï¸ [Development Workflow](.cursor/rules/development-workflow.md)
- **MANDATORY**: Build and run tests after every Swift file change
- Git workflow and commit requirements
- Test execution guidelines
- Failure response protocols

### ğŸš¨ [Error Handling](.cursor/rules/error-handling.md)
- Standardized error response handling
- Custom error types for API responses
- User-friendly error messages
- Logging patterns and security

### ğŸ”— [API Integration](.cursor/rules/api-integration.md)
- RESTful client conventions
- Request/response model patterns
- JWT token management
- Polling strategies and optimization

### ğŸ” [Security Rules](.cursor/rules/security.md)
- JWT token storage and management
- Keychain integration
- API security best practices
- Push notification token handling

## âš¡ Quick Start Checklist

### Before Making ANY Changes:
1. âœ… Read the relevant rule files above
2. âœ… Understand the feature-based MVVM architecture
3. âœ… Build project and run tests to ensure they pass

### When Adding New Features:
1. âœ… Create feature directory: `MoneyApp/Features/NewFeature/`
2. âœ… Follow the 4-layer pattern: `Views/`, `ViewModels/`, `Models/`, `Services/`
3. âœ… Write tests FIRST: unit tests for ViewModels and Services
4. âœ… Use Codable for all API contracts
5. âœ… Implement proper async/await patterns

### After Making Changes:
1. âœ… **MANDATORY**: Build project (Cmd+B) and run tests (Cmd+U)
2. âœ… Verify no SwiftUI preview errors
3. âœ… Check API responses match Codable models
4. âœ… Test polling behavior in simulator

## ğŸš« Never Do These Things:

- âŒ **Never commit without building and testing**
- âŒ Never mix business logic in SwiftUI Views
- âŒ Never cache API responses (use polling only)
- âŒ Never hardcode API endpoints or secrets
- âŒ Never ignore compiler warnings
- âŒ Never use force unwrapping without explicit safety
- âŒ Never organize code by technical layer (all views/, all models/, etc.)

## âœ… Always Do These Things:

- âœ… **Always build and test after changing Swift files**
- âœ… Always use @ObservableObject for ViewModels
- âœ… Always delegate API calls to Services
- âœ… Always use async/await for networking
- âœ… Always handle errors gracefully
- âœ… Always validate with Codable models
- âœ… Always organize by feature domain

## ğŸª Architecture Quick Reference

```
MoneyApp/
â”œâ”€â”€ Features/                  # â† Organize by business domain (mirrors backend)
â”‚   â”œâ”€â”€ Auth/                 # Authentication feature
â”‚   â”‚   â”œâ”€â”€ Views/            # SwiftUI views only
â”‚   â”‚   â”œâ”€â”€ ViewModels/       # @ObservableObject business logic
â”‚   â”‚   â”œâ”€â”€ Models/           # Codable models
â”‚   â”‚   â””â”€â”€ Services/         # API calls and networking
â”‚   â”œâ”€â”€ Accounts/             # Account management
â”‚   â”œâ”€â”€ Transactions/         # Transaction handling
â”‚   â””â”€â”€ Notifications/        # Push notifications
â”œâ”€â”€ Shared/                   # Cross-feature components
â”‚   â”œâ”€â”€ Models/              # Common Codable models
â”‚   â”œâ”€â”€ Views/               # Reusable SwiftUI components
â”‚   â””â”€â”€ Services/            # Shared networking utilities
â”œâ”€â”€ Core/                    # Infrastructure
â”‚   â”œâ”€â”€ Networking/          # Base API client
â”‚   â”œâ”€â”€ Security/            # JWT & Keychain utilities
â”‚   â””â”€â”€ Configuration/       # App settings
â””â”€â”€ Resources/               # Assets, strings, etc.
```

## ğŸ§ª Testing Quick Reference

```bash
# Essential commands (run after EVERY Swift file change)
# In Xcode:
Cmd+B                           # Build - must succeed
Cmd+U                           # Run all tests - must pass
Cmd+Shift+K                     # Clean build folder

# Feature-specific testing
# Use Test Navigator to run specific test targets:
AuthTests                       # Authentication tests
AccountsTests                   # Account management tests
TransactionsTests               # Transaction handling tests
```

## ğŸ”— MVVM Pattern Quick Reference

```swift
// View Layer (SwiftUI) - UI concerns only
struct LoginView: View {
    @StateObject private var viewModel = LoginViewModel()
    
    var body: some View {
        VStack {
            TextField("Email", text: $viewModel.email)
            SecureField("Password", text: $viewModel.password)
            Button("Login") {
                Task { await viewModel.login() }  // â† Delegate to ViewModel
            }
        }
        .alert("Error", isPresented: $viewModel.showError) {
            Button("OK") { }
        } message: {
            Text(viewModel.errorMessage)  // â† ViewModel handles errors
        }
    }
}

// ViewModel Layer (@ObservableObject) - Business logic only
@MainActor
class LoginViewModel: ObservableObject {
    @Published var email = ""
    @Published var password = ""
    @Published var isLoading = false
    @Published var showError = false
    @Published var errorMessage = ""
    
    private let authService = AuthService()
    
    func login() async {
        isLoading = true
        do {
            let request = LoginRequest(email: email, password: password)
            let response = try await authService.login(request)  // â† Delegate to Service
            // Handle success...
        } catch {
            handleError(error)  // â† Proper error handling
        }
        isLoading = false
    }
}

// Service Layer - API calls only
class AuthService {
    private let apiClient = APIClient.shared
    
    func login(_ request: LoginRequest) async throws -> AuthResponse {
        return try await apiClient.post("/api/auth/login", body: request)
    }
}

// Model Layer (Codable) - Data contracts
struct LoginRequest: Codable {
    let email: String
    let password: String
}

struct AuthResponse: Codable {
    let accessToken: String
    let user: User
}
```

## ğŸ“‹ Code Review Checklist

When reviewing or writing code, ensure:

### Architecture âœ…
- [ ] Code is organized by feature, not layer
- [ ] Views only handle UI concerns
- [ ] Business logic is in ViewModels
- [ ] API calls are in Services
- [ ] Codable models define API contracts

### SwiftUI & Concurrency âœ…
- [ ] Views use @StateObject for ViewModels
- [ ] ViewModels are @MainActor classes
- [ ] Async operations use async/await
- [ ] Proper Task { } usage in views
- [ ] No force unwrapping without safety

### Testing âœ…
- [ ] Unit tests for ViewModel methods
- [ ] Unit tests for Service methods
- [ ] UI tests for critical user flows
- [ ] Mock services for testing
- [ ] All tests pass with good coverage

### Security âœ…
- [ ] No hardcoded secrets
- [ ] JWT tokens stored securely
- [ ] API client uses proper authentication
- [ ] No sensitive data in logs

### Error Handling âœ…
- [ ] Specific error types for API responses
- [ ] User-friendly error messages
- [ ] Graceful degradation on failures
- [ ] Proper async error propagation

## ğŸ¯ API Integration Patterns

### Polling Strategy (No Caching)
```swift
class TransactionViewModel: ObservableObject {
    @Published var transactions: [Transaction] = []
    private let transactionService = TransactionService()
    
    func startPolling() {
        Task {
            while !Task.isCancelled {
                await refreshTransactions()
                try? await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds
            }
        }
    }
    
    private func refreshTransactions() async {
        do {
            transactions = try await transactionService.getRecent()
        } catch {
            // Handle polling errors gracefully
        }
    }
}
```

### JWT Token Management
```swift
class APIClient {
    private var authToken: String? {
        KeychainService.shared.getToken()
    }
    
    func authenticatedRequest<T: Codable>(_ endpoint: String) async throws -> T {
        guard let token = authToken else {
            throw APIError.notAuthenticated
        }
        // Use token in Authorization header...
    }
}
```

## ğŸš€ Backend Integration Reference

The iOS app integrates with these backend endpoints:

### Authentication
- `POST /api/auth/register` â†’ `AuthService.register()`
- `POST /api/auth/login` â†’ `AuthService.login()`
- `POST /api/auth/device-token` â†’ `AuthService.updateDeviceToken()`

### Accounts
- `POST /api/accounts/link/token` â†’ `AccountService.createLinkToken()`
- `POST /api/accounts/link/exchange` â†’ `AccountService.linkAccount()`
- `GET /api/accounts/` â†’ `AccountService.getAccounts()`
- `GET /api/accounts/sync/status` â†’ `AccountService.getSyncStatus()` (polling)

### Transactions
- `GET /api/transactions/recent` â†’ `TransactionService.getRecent()` (polling)
- `GET /api/transactions/` â†’ `TransactionService.getTransactions()`
- `GET /api/transactions/summary` â†’ `TransactionService.getSummary()`

### Notifications
- `POST /api/notifications/test` â†’ `NotificationService.sendTest()`

## ğŸª Remember

This architecture enables:
- **ğŸš€ Fast development**: Clear MVVM patterns reduce decision fatigue
- **ğŸ”§ Easy maintenance**: Features are isolated and testable
- **ğŸ‘¥ Team collaboration**: Consistent conventions across the codebase
- **ğŸ¯ Quality assurance**: Tests catch regressions automatically
- **ğŸ“ˆ Scalability**: Add features without affecting existing code
- **âš¡ Real-time updates**: Efficient polling keeps data fresh

**Every Swift file change requires building and testing. No exceptions.** ğŸ§ª

## ğŸ†˜ Need Help?

1. ğŸ“– **Read the specific rule files** in `.cursor/rules/`
2. ğŸ” **Look at existing features** for patterns to follow
3. ğŸ—ï¸ **Mirror the backend structure** for consistency
4. ğŸ§ª **Build and test early and often** to catch issues quickly
5. ğŸª **Follow the established MVVM patterns** for consistency