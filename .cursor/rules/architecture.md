# üèóÔ∏è iOS Architecture Rules

## Core Principles

This iOS app follows a **strict MVVM pattern** with **feature-based organization** that mirrors the backend structure. Every feature is self-contained with clear separation of concerns.

## üìÅ Feature-Based Organization

### Required Directory Structure

```
MoneyApp/
‚îú‚îÄ‚îÄ Features/                    # Business domains (mirrors backend)
‚îÇ   ‚îú‚îÄ‚îÄ Auth/                   # Authentication & user management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/              # SwiftUI views only
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RegisterView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProfileView.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/         # @ObservableObject business logic
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RegisterViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProfileViewModel.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Models/             # Codable data structures
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ User.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginRequest.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AuthResponse.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Services/           # API networking
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ AuthService.swift
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Accounts/               # Bank account management & Plaid
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AccountListView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PlaidLinkView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AccountDetailView.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AccountListViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PlaidLinkViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AccountDetailViewModel.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Account.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PlaidItem.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LinkTokenResponse.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Services/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ AccountService.swift
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Transactions/           # Financial transactions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransactionListView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransactionDetailView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SpendingSummaryView.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransactionListViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransactionDetailViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SpendingSummaryViewModel.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Transaction.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SpendingSummary.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TransactionCategory.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Services/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ TransactionService.swift
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ Notifications/          # Push notifications
‚îÇ       ‚îú‚îÄ‚îÄ Views/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ NotificationSettingsView.swift
‚îÇ       ‚îú‚îÄ‚îÄ ViewModels/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ NotificationSettingsViewModel.swift
‚îÇ       ‚îú‚îÄ‚îÄ Models/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ NotificationPreferences.swift
‚îÇ       ‚îî‚îÄ‚îÄ Services/
‚îÇ           ‚îî‚îÄ‚îÄ NotificationService.swift
‚îÇ
‚îú‚îÄ‚îÄ Shared/                     # Cross-feature components
‚îÇ   ‚îú‚îÄ‚îÄ Models/                 # Common data structures
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ APIResponse.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ APIError.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PaginationInfo.swift
‚îÇ   ‚îú‚îÄ‚îÄ Views/                  # Reusable UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoadingView.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ErrorView.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PullToRefreshView.swift
‚îÇ   ‚îî‚îÄ‚îÄ Services/               # Shared networking utilities
‚îÇ       ‚îú‚îÄ‚îÄ APIClient.swift
‚îÇ       ‚îî‚îÄ‚îÄ KeychainService.swift
‚îÇ
‚îú‚îÄ‚îÄ Core/                       # Infrastructure & configuration
‚îÇ   ‚îú‚îÄ‚îÄ Networking/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NetworkManager.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RequestBuilder.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ResponseParser.swift
‚îÇ   ‚îú‚îÄ‚îÄ Security/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TokenManager.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BiometricAuth.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SecureStorage.swift
‚îÇ   ‚îî‚îÄ‚îÄ Configuration/
‚îÇ       ‚îú‚îÄ‚îÄ AppConfig.swift
‚îÇ       ‚îú‚îÄ‚îÄ Environment.swift
‚îÇ       ‚îî‚îÄ‚îÄ Constants.swift
‚îÇ
‚îî‚îÄ‚îÄ Resources/                  # Assets, strings, etc.
    ‚îú‚îÄ‚îÄ Assets.xcassets/
    ‚îú‚îÄ‚îÄ Localizable.strings
    ‚îî‚îÄ‚îÄ Info.plist
```

## üé≠ MVVM Layer Responsibilities

### 1. Views (SwiftUI) - UI Only
**Purpose**: Handle user interface and user interactions only

**‚úÖ DO:**
- Define SwiftUI layout and styling
- Handle user input (buttons, text fields)
- Display data from ViewModels
- Navigate between screens
- Show loading/error states

**‚ùå DON'T:**
- Make API calls directly
- Contain business logic
- Store application state
- Perform data transformations
- Handle authentication

```swift
// ‚úÖ GOOD: View focuses on UI only
struct LoginView: View {
    @StateObject private var viewModel = LoginViewModel()
    
    var body: some View {
        VStack {
            TextField("Email", text: $viewModel.email)
            SecureField("Password", text: $viewModel.password)
            
            Button("Login") {
                Task { await viewModel.login() }
            }
            .disabled(viewModel.isLoading)
        }
        .alert("Error", isPresented: $viewModel.showError) {
            Button("OK") { }
        } message: {
            Text(viewModel.errorMessage)
        }
    }
}

// ‚ùå BAD: View contains business logic
struct LoginView: View {
    @State private var email = ""
    @State private var password = ""
    
    var body: some View {
        VStack {
            TextField("Email", text: $email)
            SecureField("Password", text: $password)
            
            Button("Login") {
                // ‚ùå DON'T: API call in view
                Task {
                    let request = LoginRequest(email: email, password: password)
                    let response = try await APIClient.shared.post("/auth/login", body: request)
                    // Handle response...
                }
            }
        }
    }
}
```

### 2. ViewModels (@ObservableObject) - Business Logic

**Purpose**: Contain all business logic and coordinate between Views and Services

**‚úÖ DO:**
- Manage @Published properties for UI state
- Coordinate API calls through Services
- Handle error states and messages
- Transform data for UI presentation
- Manage loading states
- Implement business rules

**‚ùå DON'T:**
- Make direct API calls (use Services instead)
- Contain UI-specific code
- Store credentials or tokens
- Implement networking logic

```swift
// ‚úÖ GOOD: ViewModel handles business logic
@MainActor
class LoginViewModel: ObservableObject {
    @Published var email = ""
    @Published var password = ""
    @Published var isLoading = false
    @Published var showError = false
    @Published var errorMessage = ""
    
    private let authService = AuthService()
    
    func login() async {
        guard isValidInput() else {
            showErrorMessage("Please enter valid email and password")
            return
        }
        
        isLoading = true
        do {
            let request = LoginRequest(email: email, password: password)
            let response = try await authService.login(request)
            handleSuccessfulLogin(response)
        } catch {
            handleError(error)
        }
        isLoading = false
    }
    
    private func isValidInput() -> Bool {
        !email.isEmpty && !password.isEmpty && email.contains("@")
    }
    
    private func handleError(_ error: Error) {
        errorMessage = error.localizedDescription
        showError = true
    }
}
```

### 3. Services - API Integration

**Purpose**: Handle all networking and API communication

**‚úÖ DO:**
- Make HTTP requests to backend
- Handle request/response serialization
- Manage authentication headers
- Implement retry logic
- Handle network errors

**‚ùå DON'T:**
- Contain business logic
- Manage UI state
- Transform data for UI (return raw API responses)
- Store credentials

```swift
// ‚úÖ GOOD: Service handles API communication only
class AuthService {
    private let apiClient = APIClient.shared
    
    func login(_ request: LoginRequest) async throws -> AuthResponse {
        return try await apiClient.post("/api/auth/login", body: request)
    }
    
    func register(_ request: RegisterRequest) async throws -> AuthResponse {
        return try await apiClient.post("/api/auth/register", body: request)
    }
    
    func updateDeviceToken(_ token: String) async throws {
        let request = DeviceTokenRequest(deviceToken: token)
        try await apiClient.post("/api/auth/device-token", body: request)
    }
}
```

### 4. Models (Codable) - Data Contracts

**Purpose**: Define data structures that match backend API schemas

**‚úÖ DO:**
- Mirror backend Pydantic schemas exactly
- Use Codable for JSON serialization
- Include proper property names (snake_case ‚Üí camelCase)
- Add computed properties for UI convenience

**‚ùå DON'T:**
- Include business logic
- Store state or behavior
- Contain networking code

```swift
// ‚úÖ GOOD: Model matches backend schema
struct User: Codable, Identifiable {
    let id: Int
    let email: String
    let firstName: String?
    let lastName: String?
    let isActive: Bool
    let createdAt: Date
    let deviceToken: String?
    
    // Computed properties for UI convenience
    var displayName: String {
        if let firstName = firstName, let lastName = lastName {
            return "\(firstName) \(lastName)"
        } else if let firstName = firstName {
            return firstName
        } else {
            return email
        }
    }
    
    // CodingKeys to match backend snake_case
    enum CodingKeys: String, CodingKey {
        case id, email
        case firstName = "first_name"
        case lastName = "last_name"
        case isActive = "is_active"
        case createdAt = "created_at"
        case deviceToken = "device_token"
    }
}
```

## üîÑ Data Flow Pattern

The data should flow in a unidirectional pattern:

```
User Interaction ‚Üí View ‚Üí ViewModel ‚Üí Service ‚Üí API
                ‚Üë                              ‚Üì
                ‚îî‚îÄ‚îÄ Update UI ‚Üê Transform ‚Üê Response
```

1. **User Interaction**: User taps button, enters text, etc.
2. **View**: Calls appropriate ViewModel method
3. **ViewModel**: Validates input, calls Service
4. **Service**: Makes API request
5. **API Response**: Returns data
6. **Service**: Returns raw response to ViewModel
7. **ViewModel**: Transforms data, updates @Published properties
8. **View**: Automatically updates via @StateObject binding

## üö® Architecture Violations

### ‚ùå Common Anti-Patterns

```swift
// ‚ùå DON'T: View making API calls
struct TransactionListView: View {
    @State private var transactions: [Transaction] = []
    
    var body: some View {
        List(transactions) { transaction in
            TransactionRow(transaction: transaction)
        }
        .onAppear {
            // ‚ùå BAD: API call in view
            Task {
                transactions = try await APIClient.shared.get("/api/transactions")
            }
        }
    }
}

// ‚ùå DON'T: Service containing business logic
class TransactionService {
    func getTransactions() async throws -> [Transaction] {
        let transactions = try await apiClient.get("/api/transactions")
        
        // ‚ùå BAD: Business logic in service
        let filtered = transactions.filter { $0.amount > 100 }
        let sorted = filtered.sorted { $0.date > $1.date }
        
        return sorted
    }
}

// ‚ùå DON'T: Model with networking
struct Transaction: Codable {
    let id: Int
    let amount: Decimal
    let date: Date
    
    // ‚ùå BAD: Networking in model
    func sync() async throws {
        try await APIClient.shared.post("/api/transactions/\(id)/sync")
    }
}
```

### ‚úÖ Correct Architecture

```swift
// ‚úÖ GOOD: View delegates to ViewModel
struct TransactionListView: View {
    @StateObject private var viewModel = TransactionListViewModel()
    
    var body: some View {
        List(viewModel.filteredTransactions) { transaction in
            TransactionRow(transaction: transaction)
        }
        .onAppear {
            Task { await viewModel.loadTransactions() }
        }
    }
}

// ‚úÖ GOOD: ViewModel contains business logic
@MainActor
class TransactionListViewModel: ObservableObject {
    @Published var transactions: [Transaction] = []
    @Published var minAmount: Decimal = 0
    
    private let transactionService = TransactionService()
    
    var filteredTransactions: [Transaction] {
        transactions
            .filter { $0.amount > minAmount }
            .sorted { $0.date > $1.date }
    }
    
    func loadTransactions() async {
        do {
            transactions = try await transactionService.getTransactions()
        } catch {
            // Handle error
        }
    }
}

// ‚úÖ GOOD: Service only handles API
class TransactionService {
    private let apiClient = APIClient.shared
    
    func getTransactions() async throws -> [Transaction] {
        return try await apiClient.get("/api/transactions")
    }
}

// ‚úÖ GOOD: Model is pure data
struct Transaction: Codable, Identifiable {
    let id: Int
    let amount: Decimal
    let date: Date
    let merchantName: String
    let category: String
}
```

## üì± SwiftUI Specific Guidelines

### State Management

```swift
// ‚úÖ GOOD: Proper state object usage
struct ContentView: View {
    @StateObject private var authViewModel = AuthViewModel()  // Owner
    
    var body: some View {
        if authViewModel.isAuthenticated {
            MainTabView()
                .environmentObject(authViewModel)  // Pass down
        } else {
            LoginView()
        }
    }
}

struct MainTabView: View {
    @EnvironmentObject var authViewModel: AuthViewModel  // Receive from parent
    
    var body: some View {
        TabView {
            TransactionListView()
                .tabItem { Label("Transactions", systemImage: "list.bullet") }
        }
    }
}
```

### Navigation Patterns

```swift
// ‚úÖ GOOD: NavigationStack with proper data passing
struct TransactionListView: View {
    @StateObject private var viewModel = TransactionListViewModel()
    
    var body: some View {
        NavigationStack {
            List(viewModel.transactions) { transaction in
                NavigationLink {
                    TransactionDetailView(transaction: transaction)
                } label: {
                    TransactionRow(transaction: transaction)
                }
            }
            .navigationTitle("Transactions")
        }
    }
}
```

## üîÑ Adding New Features

### Step-by-Step Process

1. **Create Feature Directory Structure**
```bash
mkdir -p MoneyApp/Features/NewFeature/{Views,ViewModels,Models,Services}
```

2. **Define Models** (API contracts first)
```swift
// Models/NewFeatureRequest.swift
struct NewFeatureRequest: Codable {
    let parameter: String
}

// Models/NewFeatureResponse.swift
struct NewFeatureResponse: Codable {
    let id: Int
    let result: String
}
```

3. **Create Service** (API integration)
```swift
// Services/NewFeatureService.swift
class NewFeatureService {
    private let apiClient = APIClient.shared
    
    func performAction(_ request: NewFeatureRequest) async throws -> NewFeatureResponse {
        return try await apiClient.post("/api/new-feature", body: request)
    }
}
```

4. **Implement ViewModel** (Business logic)
```swift
// ViewModels/NewFeatureViewModel.swift
@MainActor
class NewFeatureViewModel: ObservableObject {
    @Published var isLoading = false
    @Published var result: String?
    
    private let service = NewFeatureService()
    
    func performAction(parameter: String) async {
        // Business logic implementation
    }
}
```

5. **Create View** (UI)
```swift
// Views/NewFeatureView.swift
struct NewFeatureView: View {
    @StateObject private var viewModel = NewFeatureViewModel()
    
    var body: some View {
        // SwiftUI implementation
    }
}
```

6. **Write Tests** (Test-driven development)
```swift
// Tests/NewFeatureViewModelTests.swift
// Tests/NewFeatureServiceTests.swift
```

## üéØ Architecture Benefits

This architecture provides:

- **üîß Maintainability**: Clear separation makes code easy to modify
- **üß™ Testability**: Each layer can be tested independently
- **‚ôªÔ∏è Reusability**: Services and models can be shared across features
- **üé™ Consistency**: Standardized patterns across all features
- **üöÄ Scalability**: Add new features without affecting existing ones
- **üîÑ Backend Alignment**: Structure mirrors backend for easier integration

## üìö Quick Reference Checklist

Before submitting code, verify:

- [ ] Code is organized by feature, not technical layer
- [ ] Views only contain SwiftUI UI code
- [ ] ViewModels handle all business logic
- [ ] Services only make API calls
- [ ] Models are pure Codable data structures
- [ ] No direct API calls in Views
- [ ] Proper async/await usage
- [ ] @MainActor on ViewModels
- [ ] @StateObject for ViewModel ownership