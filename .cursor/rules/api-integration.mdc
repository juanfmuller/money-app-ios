---
globs: *.swift
alwaysApply: false
---

# üîó iOS API Integration Rules

## API Integration Philosophy

This iOS app uses **polling-based data synchronization** with the FastAPI backend. No caching is implemented - all data is fetched fresh on demand for maximum simplicity and fast iteration.

## üìã Data Models (Codable)
**üö® MANDATORY üö®** Always check for /Generated models before implementing. `import MoneyAppGenerated`

### Request Models
**AUTOMATICALLY GENERATED** Found in `money-app-ios/Generated`

### Response Models
**AUTOMATICALLY GENERATED** Found in `money-app-ios/Generated`

## üì± Polling Strategy Implementation

### Automatic Background Polling

**‚úÖ DO:**
- Always use polling for "real-time" data
- Use async/await for everything

**‚ùå DON'T:**
- Don't use Combine
- Don't implement caching

## üéØ Integration Architecture

### Backend API Overview

The Money App backend provides these key endpoints:

```swift
// Authentication Endpoints
POST /api/auth/register     // Create new user account
POST /api/auth/login        // User login with JWT token
POST /api/auth/device-token // Update iOS device token for push notifications

// Account Management Endpoints  
POST /api/accounts/link/token    // Create Plaid Link token
POST /api/accounts/link/exchange // Link bank account via Plaid
GET  /api/accounts/             // Get user's linked accounts
POST /api/accounts/sync         // Manual account/transaction sync
GET  /api/accounts/sync/status  // Get sync status (for polling)

// Transaction Endpoints
GET /api/transactions/          // Get transactions with filtering/pagination
GET /api/transactions/recent    // Get recent transactions (optimized for polling)  
GET /api/transactions/summary   // Get spending summary and analytics
GET /api/transactions/categories // Get available spending categories

// Notification Endpoints
POST /api/notifications/test    // Send test push notification
GET  /api/notifications/preferences // Get notification settings
```

## üèóÔ∏è Service Layer Architecture

### Base API Client

```swift
// ‚úÖ GOOD: Centralized API client with JWT auth
class APIClient {
    static let shared = APIClient()
    
    private let baseURL: URL
    private let session: URLSession
    private let jsonDecoder: JSONDecoder
    private let jsonEncoder: JSONEncoder
    
    init() {
        self.baseURL = URL(string: AppConfig.apiBaseURL)!
        
        // Configure session with reasonable timeouts
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 30
        config.timeoutIntervalForResource = 60
        self.session = URLSession(configuration: config)
        
        // Configure JSON handling
        self.jsonDecoder = JSONDecoder()
        self.jsonDecoder.dateDecodingStrategy = .iso8601
        self.jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase
        
        self.jsonEncoder = JSONEncoder()
        self.jsonEncoder.dateEncodingStrategy = .iso8601
        self.jsonEncoder.keyEncodingStrategy = .convertToSnakeCase
    }
    
    // GET request
    func get<T: Codable>(_ endpoint: String, queryParams: [String: String] = [:]) async throws -> T {
        let request = try buildRequest(method: "GET", endpoint: endpoint, queryParams: queryParams)
        return try await performRequest(request)
    }
    
    // POST request with body
    func post<T: Codable, U: Codable>(_ endpoint: String, body: U) async throws -> T {
        let request = try buildRequest(method: "POST", endpoint: endpoint, body: body)
        return try await performRequest(request)
    }
    
    // POST request without body
    func post<T: Codable>(_ endpoint: String) async throws -> T {
        let request = try buildRequest(method: "POST", endpoint: endpoint)
        return try await performRequest(request)
    }
    
    // PUT request
    func put<T: Codable, U: Codable>(_ endpoint: String, body: U) async throws -> T {
        let request = try buildRequest(method: "PUT", endpoint: endpoint, body: body)
        return try await performRequest(request)
    }
    
    // DELETE request
    func delete<T: Codable>(_ endpoint: String) async throws -> T {
        let request = try buildRequest(method: "DELETE", endpoint: endpoint)
        return try await performRequest(request)
    }
    
    private func buildRequest<T: Codable>(
        method: String,
        endpoint: String,
        queryParams: [String: String] = [:],
        body: T? = nil
    ) throws -> URLRequest {
        // Build URL with query parameters
        var urlComponents = URLComponents(url: baseURL.appendingPathComponent(endpoint), resolvingAgainstBaseURL: false)!
        
        if !queryParams.isEmpty {
            urlComponents.queryItems = queryParams.map { URLQueryItem(name: $0.key, value: $0.value) }
        }
        
        guard let url = urlComponents.url else {
            throw APIError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = method
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        
        // Add authentication header if token exists
        if let token = TokenManager.shared.getAccessToken() {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        
        // Add body if provided
        if let body = body {
            do {
                request.httpBody = try jsonEncoder.encode(body)
            } catch {
                throw APIError.encodingError
            }
        }
        
        return request
    }
    
    private func performRequest<T: Codable>(_ request: URLRequest) async throws -> T {
        do {
            let (data, response) = try await session.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                throw APIError.networkError
            }
            
            switch httpResponse.statusCode {
            case 200...299:
                do {
                    return try jsonDecoder.decode(T.self, from: data)
                } catch {
                    print("üî¥ Decoding error for \(request.url?.path ?? "unknown"): \(error)")
                    throw APIError.decodingError
                }
                
            case 401:
                // Clear invalid token and throw auth error
                TokenManager.shared.clearTokens()
                throw APIError.unauthorized
                
            case 403:
                throw APIError.forbidden
            case 404:
                throw APIError.notFound
            case 408:
                throw APIError.requestTimeout
            case 500...599:
                throw APIError.serverError(httpResponse.statusCode)
            default:
                throw APIError.networkError
            }
            
        } catch let error as APIError {
            throw error
        } catch let urlError as URLError {
            switch urlError.code {
            case .notConnectedToInternet, .networkConnectionLost:
                throw APIError.noInternetConnection
            case .timedOut:
                throw APIError.requestTimeout
            default:
                throw APIError.networkError
            }
        } catch {
            throw APIError.networkError
        }
    }
}
```

### Feature-Specific Services with Actor Pattern

```swift
// ‚úÖ GOOD: Protocol-based authentication service with actor
protocol AuthServiceProtocol: Sendable {
    func register(_ request: RegisterRequest) async throws -> AuthResponse
    func login(_ request: LoginRequest) async throws -> AuthResponse
    func updateDeviceToken(_ token: String) async throws
    func logout() async throws
}

// ‚úÖ GOOD: Protocol-based account service with actor
protocol AccountServiceProtocol: Sendable {
    func createLinkToken() async throws -> LinkTokenResponse
    func exchangePublicToken(_ publicToken: String) async throws -> ExchangeResponse
    func getAccounts() async throws -> AccountListResponse
    func syncAccounts() async throws -> SyncResponse
    func getSyncStatus() async throws -> SyncStatusResponse
}

// ‚úÖ GOOD: Protocol-based transaction service with actor
protocol TransactionServiceProtocol: Sendable {
    func getTransactions(limit: Int, offset: Int, startDate: Date?, endDate: Date?, category: String?) async throws -> TransactionListResponse
    func getRecentTransactions(since: Date?) async throws -> RecentTransactionsResponse
    func getSpendingSummary(startDate: Date, endDate: Date) async throws -> SpendingSummaryResponse
    func getCategories() async throws -> CategoriesResponse
}
```

## üìö Remember

This polling-based approach enables:

- **üöÄ Simple Architecture**: No complex caching or state management
- **‚ö° Fast Iteration**: Easy to debug and modify

**Keep API integration simple and focused on the backend generated contracts.** üéØ