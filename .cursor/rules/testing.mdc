---
globs: *.swift
alwaysApply: false
---

# ğŸ§ª iOS Testing Rules

## Testing Philosophy

This iOS app follows a **comprehensive testing strategy** with unit tests for ViewModels and Services, plus UI tests for critical user flows. Tests are organized by feature and follow TDD principles.

## ğŸ“ Test Organization Structure

```
MoneyAppTests/
â”œâ”€â”€ Features/                   # Feature-specific tests
â”‚   â”œâ”€â”€ Auth/
â”‚   â”‚   â”œâ”€â”€ ViewModels/
â”‚   â”‚   â”‚   â”œâ”€â”€ LoginViewModelTests.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ RegisterViewModelTests.swift
â”‚   â”‚   â”‚   â””â”€â”€ ProfileViewModelTests.swift
â”‚   â”‚   â”œâ”€â”€ Services/
â”‚   â”‚   â”‚   â””â”€â”€ AuthServiceTests.swift
â”‚   â”‚   â””â”€â”€ Models/
â”‚   â”‚       â””â”€â”€ UserTests.swift
â”‚   â”‚
â”‚   â”œâ”€â”€ Accounts/
â”‚   â”‚   â”œâ”€â”€ ViewModels/
â”‚   â”‚   â”‚   â”œâ”€â”€ AccountListViewModelTests.swift
â”‚   â”‚   â”‚   â””â”€â”€ PlaidLinkViewModelTests.swift
â”‚   â”‚   â””â”€â”€ Services/
â”‚   â”‚       â””â”€â”€ AccountServiceTests.swift
â”‚   â”‚
â”‚   â”œâ”€â”€ Transactions/
â”‚   â”‚   â”œâ”€â”€ ViewModels/
â”‚   â”‚   â”‚   â”œâ”€â”€ TransactionListViewModelTests.swift
â”‚   â”‚   â”‚   â””â”€â”€ SpendingSummaryViewModelTests.swift
â”‚   â”‚   â””â”€â”€ Services/
â”‚   â”‚       â””â”€â”€ TransactionServiceTests.swift
â”‚   â”‚
â”‚   â””â”€â”€ Notifications/
â”‚       â”œâ”€â”€ ViewModels/
â”‚       â”‚   â””â”€â”€ NotificationSettingsViewModelTests.swift
â”‚       â””â”€â”€ Services/
â”‚           â””â”€â”€ NotificationServiceTests.swift
â”‚
â”œâ”€â”€ Shared/                     # Shared component tests
â”‚   â”œâ”€â”€ Services/
â”‚   â”‚   â”œâ”€â”€ APIClientTests.swift
â”‚   â”‚   â””â”€â”€ KeychainServiceTests.swift
â”‚   â””â”€â”€ Models/
â”‚       â””â”€â”€ APIResponseTests.swift
â”‚
â””â”€â”€ TestHelpers/                # Test utilities
    â”œâ”€â”€ MockServices/
    â”‚   â”œâ”€â”€ MockAuthService.swift
    â”‚   â”œâ”€â”€ MockAccountService.swift
    â”‚   â””â”€â”€ MockTransactionService.swift
    â”œâ”€â”€ TestData/
    â”‚   â”œâ”€â”€ SampleUsers.swift
    â”‚   â”œâ”€â”€ SampleTransactions.swift
    â”‚   â””â”€â”€ SampleAccounts.swift
    â””â”€â”€ Extensions/
        â””â”€â”€ XCTestCase+Helpers.swift

MoneyAppUITests/
â”œâ”€â”€ Features/
â”‚   â”œâ”€â”€ AuthUITests.swift
â”‚   â”œâ”€â”€ AccountsUITests.swift
â”‚   â””â”€â”€ TransactionsUITests.swift
â””â”€â”€ TestHelpers/
    â”œâ”€â”€ UITestHelpers.swift
    â””â”€â”€ MockAPIServer.swift
```

## ğŸ¯ Testing Layers & Responsibilities

### 1. ViewModel Tests (Primary Focus)

**Purpose**: Test business logic and state management

**âœ… Test These Scenarios:**
- State changes (@Published properties)
- Business logic validation
- Error handling and error messages
- Loading states
- Data transformation for UI
- User input validation
- Integration with Services (mocked)

```swift
// âœ… GOOD: Comprehensive ViewModel test
@MainActor
class LoginViewModelTests: XCTestCase {
    private var viewModel: LoginViewModel!
    private var mockAuthService: MockAuthService!
    
    override func setUp() {
        super.setUp()
        mockAuthService = MockAuthService()
        viewModel = LoginViewModel(authService: mockAuthService)
    }
    
    override func tearDown() {
        viewModel = nil
        mockAuthService = nil
        super.tearDown()
    }
    
    // Test successful login flow
    func testLogin_Success() async {
        // Given
        viewModel.email = "test@example.com"
        viewModel.password = "password123"
        mockAuthService.loginResult = .success(AuthResponse.sample)
        
        // When
        await viewModel.login()
        
        // Then
        XCTAssertFalse(viewModel.isLoading)
        XCTAssertFalse(viewModel.showError)
        XCTAssertTrue(viewModel.isAuthenticated)
    }
    
    // Test error handling
    func testLogin_InvalidCredentials() async {
        // Given
        viewModel.email = "wrong@example.com"
        viewModel.password = "wrongpassword"
        mockAuthService.loginResult = .failure(APIError.unauthorized)
        
        // When
        await viewModel.login()
        
        // Then
        XCTAssertFalse(viewModel.isLoading)
        XCTAssertTrue(viewModel.showError)
        XCTAssertEqual(viewModel.errorMessage, "Invalid email or password")
        XCTAssertFalse(viewModel.isAuthenticated)
    }
    
    // Test input validation
    func testLogin_EmptyEmail() async {
        // Given
        viewModel.email = ""
        viewModel.password = "password123"
        
        // When
        await viewModel.login()
        
        // Then
        XCTAssertTrue(viewModel.showError)
        XCTAssertEqual(viewModel.errorMessage, "Please enter a valid email address")
        XCTAssertEqual(mockAuthService.loginCallCount, 0) // Service not called
    }
    
    // Test loading state
    func testLogin_LoadingState() async {
        // Given
        viewModel.email = "test@example.com"
        viewModel.password = "password123"
        mockAuthService.loginDelay = 1.0
        
        // When
        let loginTask = Task { await viewModel.login() }
        
        // Then (while loading)
        XCTAssertTrue(viewModel.isLoading)
        
        await loginTask.value
        XCTAssertFalse(viewModel.isLoading)
    }
}
```

### 2. Service Tests

**Purpose**: Test API integration and networking logic

**âœ… Test These Scenarios:**
- HTTP request construction
- Response parsing
- Error handling (network, HTTP, parsing)
- Authentication header inclusion
- Retry mechanisms

```swift
// âœ… GOOD: Service test with URLSession mocking
class AuthServiceTests: XCTestCase {
    private var authService: AuthService!
    private var mockURLSession: MockURLSession!
    
    override func setUp() {
        super.setUp()
        mockURLSession = MockURLSession()
        authService = AuthService(urlSession: mockURLSession)
    }
    
    func testLogin_Success() async throws {
        // Given
        let request = LoginRequest(email: "test@example.com", password: "password123")
        let expectedResponse = AuthResponse.sample
        mockURLSession.mockData = try JSONEncoder().encode(expectedResponse)
        mockURLSession.mockResponse = HTTPURLResponse(
            url: URL(string: "https://api.example.com/auth/login")!,
            statusCode: 200,
            httpVersion: nil,
            headerFields: nil
        )
        
        // When
        let response = try await authService.login(request)
        
        // Then
        XCTAssertEqual(response.user.email, expectedResponse.user.email)
        XCTAssertEqual(mockURLSession.lastRequest?.httpMethod, "POST")
        XCTAssertEqual(mockURLSession.lastRequest?.url?.path, "/api/auth/login")
    }
    
    func testLogin_NetworkError() async {
        // Given
        let request = LoginRequest(email: "test@example.com", password: "password123")
        mockURLSession.mockError = URLError(.notConnectedToInternet)
        
        // When/Then
        do {
            _ = try await authService.login(request)
            XCTFail("Expected network error")
        } catch let error as APIError {
            XCTAssertEqual(error, .networkError)
        } catch {
            XCTFail("Unexpected error type: \(error)")
        }
    }
    
    func testLogin_InvalidResponse() async {
        // Given
        let request = LoginRequest(email: "test@example.com", password: "password123")
        mockURLSession.mockData = "Invalid JSON".data(using: .utf8)
        mockURLSession.mockResponse = HTTPURLResponse(
            url: URL(string: "https://api.example.com/auth/login")!,
            statusCode: 200,
            httpVersion: nil,
            headerFields: nil
        )
        
        // When/Then
        do {
            _ = try await authService.login(request)
            XCTFail("Expected parsing error")
        } catch let error as APIError {
            XCTAssertEqual(error, .decodingError)
        }
    }
}
```

### 3. Model Tests

**Purpose**: Test Codable compliance and data transformations

**âœ… Test These Scenarios:**
- JSON encoding/decoding
- Property mapping (snake_case â†” camelCase)
- Computed properties
- Default values

```swift
// âœ… GOOD: Model test for Codable compliance
class UserTests: XCTestCase {
    
    func testUserDecoding_CompleteData() throws {
        // Given
        let json = """
        {
            "id": 123,
            "email": "test@example.com",
            "first_name": "John",
            "last_name": "Doe",
            "is_active": true,
            "created_at": "2024-01-01T00:00:00Z",
            "device_token": "abc123"
        }
        """.data(using: .utf8)!
        
        // When
        let user = try JSONDecoder().decode(User.self, from: json)
        
        // Then
        XCTAssertEqual(user.id, 123)
        XCTAssertEqual(user.email, "test@example.com")
        XCTAssertEqual(user.firstName, "John")
        XCTAssertEqual(user.lastName, "Doe")
        XCTAssertTrue(user.isActive)
        XCTAssertEqual(user.deviceToken, "abc123")
    }
    
    func testUserDisplayName_FullName() {
        // Given
        let user = User(
            id: 1,
            email: "test@example.com",
            firstName: "John",
            lastName: "Doe",
            isActive: true,
            createdAt: Date(),
            deviceToken: nil
        )
        
        // When/Then
        XCTAssertEqual(user.displayName, "John Doe")
    }
    
    func testUserDisplayName_FirstNameOnly() {
        // Given
        let user = User(
            id: 1,
            email: "test@example.com",
            firstName: "John",
            lastName: nil,
            isActive: true,
            createdAt: Date(),
            deviceToken: nil
        )
        
        // When/Then
        XCTAssertEqual(user.displayName, "John")
    }
    
    func testUserDisplayName_EmailFallback() {
        // Given
        let user = User(
            id: 1,
            email: "test@example.com",
            firstName: nil,
            lastName: nil,
            isActive: true,
            createdAt: Date(),
            deviceToken: nil
        )
        
        // When/Then
        XCTAssertEqual(user.displayName, "test@example.com")
    }
}
```

### 4. UI Tests (Critical Flows Only)

**Purpose**: Test end-to-end user workflows

**âœ… Test These Scenarios:**
- Complete authentication flow
- Account linking process
- Transaction viewing and filtering
- Error state handling
- Navigation flows

```swift
// âœ… GOOD: UI test for critical flow
class AuthUITests: XCTestCase {
    private var app: XCUIApplication!
    
    override func setUp() {
        super.setUp()
        app = XCUIApplication()
        app.launchArguments = ["--uitesting"]
        app.launch()
    }
    
    func testCompleteLoginFlow() {
        // Given - User is on login screen
        let emailField = app.textFields["Email"]
        let passwordField = app.secureTextFields["Password"]
        let loginButton = app.buttons["Login"]
        
        XCTAssertTrue(emailField.exists)
        XCTAssertTrue(passwordField.exists)
        XCTAssertTrue(loginButton.exists)
        
        // When - User enters credentials and logs in
        emailField.tap()
        emailField.typeText("test@example.com")
        
        passwordField.tap()
        passwordField.typeText("password123")
        
        loginButton.tap()
        
        // Then - User should be on main screen
        let transactionsTab = app.tabBars.buttons["Transactions"]
        XCTAssertTrue(transactionsTab.waitForExistence(timeout: 5))
    }
    
    func testLoginError_InvalidCredentials() {
        // Given
        let emailField = app.textFields["Email"]
        let passwordField = app.secureTextFields["Password"]
        let loginButton = app.buttons["Login"]
        
        // When - User enters invalid credentials
        emailField.tap()
        emailField.typeText("wrong@example.com")
        
        passwordField.tap()
        passwordField.typeText("wrongpassword")
        
        loginButton.tap()
        
        // Then - Error alert should appear
        let errorAlert = app.alerts["Error"]
        XCTAssertTrue(errorAlert.waitForExistence(timeout: 5))
        XCTAssertTrue(errorAlert.staticTexts["Invalid email or password"].exists)
        
        errorAlert.buttons["OK"].tap()
    }
}
```

## ğŸ­ Mock Services Pattern

### Creating Mock Services

```swift
// âœ… GOOD: Comprehensive mock service
class MockAuthService: AuthServiceProtocol {
    var loginResult: Result<AuthResponse, Error> = .success(AuthResponse.sample)
    var registerResult: Result<AuthResponse, Error> = .success(AuthResponse.sample)
    var updateDeviceTokenResult: Result<Void, Error> = .success(())
    
    var loginCallCount = 0
    var registerCallCount = 0
    var updateDeviceTokenCallCount = 0
    
    var loginDelay: TimeInterval = 0
    var registerDelay: TimeInterval = 0
    
    func login(_ request: LoginRequest) async throws -> AuthResponse {
        loginCallCount += 1
        
        if loginDelay > 0 {
            try await Task.sleep(nanoseconds: UInt64(loginDelay * 1_000_000_000))
        }
        
        switch loginResult {
        case .success(let response):
            return response
        case .failure(let error):
            throw error
        }
    }
    
    func register(_ request: RegisterRequest) async throws -> AuthResponse {
        registerCallCount += 1
        
        if registerDelay > 0 {
            try await Task.sleep(nanoseconds: UInt64(registerDelay * 1_000_000_000))
        }
        
        switch registerResult {
        case .success(let response):
            return response
        case .failure(let error):
            throw error
        }
    }
    
    func updateDeviceToken(_ token: String) async throws {
        updateDeviceTokenCallCount += 1
        
        switch updateDeviceTokenResult {
        case .success:
            return
        case .failure(let error):
            throw error
        }
    }
}
```

### Service Protocol Pattern

```swift
// âœ… GOOD: Protocol for easy mocking
protocol AuthServiceProtocol {
    func login(_ request: LoginRequest) async throws -> AuthResponse
    func register(_ request: RegisterRequest) async throws -> AuthResponse
    func updateDeviceToken(_ token: String) async throws
}

// Production service
class AuthService: AuthServiceProtocol {
    private let apiClient: APIClient
    
    init(apiClient: APIClient = .shared) {
        self.apiClient = apiClient
    }
    
    func login(_ request: LoginRequest) async throws -> AuthResponse {
        return try await apiClient.post("/api/auth/login", body: request)
    }
    
    // ... other methods
}

// ViewModel uses protocol for dependency injection
@MainActor
class LoginViewModel: ObservableObject {
    private let authService: AuthServiceProtocol
    
    init(authService: AuthServiceProtocol = AuthService()) {
        self.authService = authService
    }
}
```

## ğŸ“Š Test Data Management

### Sample Data Pattern

```swift
// âœ… GOOD: Centralized test data
extension AuthResponse {
    static let sample = AuthResponse(
        accessToken: "sample_token_123",
        user: User.sample
    )
}

extension User {
    static let sample = User(
        id: 1,
        email: "test@example.com",
        firstName: "John",
        lastName: "Doe",
        isActive: true,
        createdAt: Date(),
        deviceToken: "sample_device_token"
    )
    
    static let sampleWithoutName = User(
        id: 2,
        email: "noname@example.com",
        firstName: nil,
        lastName: nil,
        isActive: true,
        createdAt: Date(),
        deviceToken: nil
    )
}

extension Transaction {
    static let sampleExpense = Transaction(
        id: 1,
        amount: 25.99,
        merchantName: "Coffee Shop",
        date: Date(),
        category: "Food and Drink",
        isPending: false
    )
    
    static let sampleIncome = Transaction(
        id: 2,
        amount: -1000.00,
        merchantName: "Payroll",
        date: Date(),
        category: "Payroll",
        isPending: false
    )
    
    static func samples(count: Int) -> [Transaction] {
        (1...count).map { index in
            Transaction(
                id: index,
                amount: Double.random(in: 1...100),
                merchantName: "Merchant \(index)",
                date: Date().addingTimeInterval(-Double(index) * 86400),
                category: ["Food", "Transportation", "Shopping"].randomElement()!,
                isPending: Bool.random()
            )
        }
    }
}
```

## ğŸš¨ Testing Anti-Patterns

### âŒ Things to Avoid

```swift
// âŒ DON'T: Test View implementation details
func testLoginView_ButtonColor() {
    // This is testing implementation, not behavior
    XCTAssertEqual(loginView.loginButton.backgroundColor, .blue)
}

// âŒ DON'T: Make real API calls in tests
func testAuthService_Login() async {
    let service = AuthService()
    // This will make a real network call
    let response = try await service.login(LoginRequest(...))
}

// âŒ DON'T: Test multiple concerns in one test
func testLoginViewModel_Everything() async {
    // Test login, validation, error handling, loading state all in one test
    // This makes it hard to identify what specifically failed
}

// âŒ DON'T: Use XCTAssertEqual for optional without unwrapping
func testUser_FirstName() {
    let user = User.sample
    XCTAssertEqual(user.firstName, "John") // firstName is optional, may crash
}
```

### âœ… Correct Patterns

```swift
// âœ… DO: Test behavior, not implementation
func testLoginViewModel_ShowsErrorOnInvalidCredentials() async {
    // Test that the ViewModel shows an error, not how it's displayed
}

// âœ… DO: Use mocks for external dependencies
func testAuthService_Login() async {
    let mockURLSession = MockURLSession()
    let service = AuthService(urlSession: mockURLSession)
    // Test with controlled mock data
}

// âœ… DO: One assertion per test
func testLoginViewModel_SetsLoadingState() async {
    // Test only loading state behavior
}

// âœ… DO: Safely unwrap optionals in tests
func testUser_FirstName() {
    let user = User.sample
    XCTAssertEqual(user.firstName, "John")
    // or
    XCTAssertNotNil(user.firstName)
    XCTAssertEqual(user.firstName!, "John")
}
```

## ğŸª Test-Driven Development (TDD)

### TDD Cycle for New Features

1. **ğŸ”´ Red**: Write failing test first
2. **ğŸŸ¢ Green**: Write minimal code to pass
3. **ğŸ”µ Blue**: Refactor and improve

```swift
// Step 1: ğŸ”´ Write failing test
func testTransactionList_FiltersExpenses() async {
    // Given
    let viewModel = TransactionListViewModel()
    viewModel.filterType = .expenses
    
    // When
    await viewModel.loadTransactions()
    
    // Then
    XCTAssertTrue(viewModel.transactions.allSatisfy { $0.amount > 0 })
    // âŒ This will fail initially
}

// Step 2: ğŸŸ¢ Write minimal implementation
@MainActor
class TransactionListViewModel: ObservableObject {
    @Published var transactions: [Transaction] = []
    @Published var filterType: FilterType = .all
    
    enum FilterType {
        case all, expenses, income
    }
    
    func loadTransactions() async {
        let allTransactions = try await transactionService.getTransactions()
        
        switch filterType {
        case .all:
            transactions = allTransactions
        case .expenses:
            transactions = allTransactions.filter { $0.amount > 0 }
        case .income:
            transactions = allTransactions.filter { $0.amount < 0 }
        }
    }
}

// Step 3: ğŸ”µ Refactor and add more tests
func testTransactionList_FiltersIncome() async {
    // Add test for income filtering
}

func testTransactionList_ShowsAllByDefault() async {
    // Add test for default behavior
}
```

## ğŸ“‹ Testing Checklist

Before submitting code, ensure:

### Unit Tests âœ…
- [ ] All ViewModels have comprehensive tests
- [ ] All Services have network mocking tests
- [ ] All Models have Codable tests
- [ ] Business logic edge cases are covered
- [ ] Error scenarios are tested
- [ ] Loading states are verified

### Test Quality âœ…
- [ ] Tests have descriptive names
- [ ] One assertion per test method
- [ ] Given/When/Then structure is clear
- [ ] Mock services are used appropriately
- [ ] Test data is isolated and repeatable

### Coverage âœ…
- [ ] All public methods are tested
- [ ] Error paths are covered
- [ ] Edge cases are handled
- [ ] Critical user flows have UI tests

### Performance âœ…
- [ ] Tests run quickly (< 1 second each)
- [ ] No real network calls in unit tests
- [ ] Mock data is lightweight
- [ ] Tests can run in parallel

## ğŸš€ Quick Commands

```bash
# Run all tests
cmd+U

# Run specific test class
Right-click test class â†’ Run

# Run single test method
Click diamond in gutter â†’ Run

# Debug test
Click diamond in gutter â†’ Debug

# View test coverage
Product â†’ Test â†’ Code Coverage
```

## ğŸ“š Testing Resources

- **XCTest Framework**: Standard iOS testing framework
- **UI Testing**: XCUITest for end-to-end testing
- **Mocking**: Protocol-based dependency injection
- **Test Data**: Centralized sample data extensions
- **Async Testing**: async/await testing patterns