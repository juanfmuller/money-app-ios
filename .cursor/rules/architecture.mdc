---
globs: *.swift
alwaysApply: false
---

# üèóÔ∏è iOS Architecture Rules

## Core Principles

This iOS app follows a **modern MVVM pattern** with **Swift 6 Observation** and **feature-based organization** that mirrors the backend structure. Every feature is self-contained with clear separation of concerns, leveraging the latest Swift concurrency and observation patterns for optimal performance.

## üìÅ Feature-Based Organization

### Required Directory Structure

```
MoneyApp/
‚îú‚îÄ‚îÄ Features/                    # Business domains (mirrors backend)
‚îÇ   ‚îú‚îÄ‚îÄ Auth/                   # Authentication & user management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/              # SwiftUI views only
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RegisterView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProfileView.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/         # @Observable business logic
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RegisterViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProfileViewModel.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Models/             # Codable data structures
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ User.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginRequest.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AuthResponse.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Services/           # API networking
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ AuthService.swift
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Accounts/               # Bank account management & Plaid
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AccountListView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PlaidLinkView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AccountDetailView.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AccountListViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PlaidLinkViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AccountDetailViewModel.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Account.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PlaidItem.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LinkTokenResponse.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Services/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ AccountService.swift
‚îÇ
‚îú‚îÄ‚îÄ Shared/                     # Cross-feature components
‚îÇ   ‚îú‚îÄ‚îÄ Models/                 # Common data structures
‚îÇ   ‚îú‚îÄ‚îÄ Views/                  # Reusable UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.swift
‚îÇ   ‚îî‚îÄ‚îÄ Services/               # Shared networking utilities
‚îÇ       ‚îî‚îÄ‚îÄ KeychainService.swift
‚îÇ
‚îú‚îÄ‚îÄ Core/                       # Infrastructure & configuration
‚îÇ   ‚îú‚îÄ‚îÄ Networking/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NetworkManager.swift
‚îÇ   ‚îú‚îÄ‚îÄ Navigation/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AppRouter.swift
```

## üé≠ MVVM Layer Responsibilities

### 1. Views (SwiftUI) - UI Only
**Purpose**: Handle user interface and user interactions only

**‚úÖ DO:**
- Define SwiftUI layout and styling
- Handle user input (buttons, text fields)
- Display data from ViewModels
- Navigate between screens
- Show loading/error states

**‚ùå DON'T:**
- Make API calls directly
- Contain business logic
- Store application state
- Perform data transformations
- Handle authentication

### 2. ViewModels (@Observable) - Business Logic

**Purpose**: Contain all business logic and coordinate between Views and Services

**‚úÖ DO:**
- Use @Observable macro for automatic observation
- Manage regular properties for UI state (no @Published needed)
- Coordinate API calls through Services
- Handle error states and messages
- Transform data for UI presentation
- Manage loading states
- Implement business rules

**‚ùå DON'T:**
- Make direct API calls (use Services instead)
- Contain UI-specific code
- Store credentials or tokens
- Implement networking logic

### 3. Services - API Integration & Protocol-Based Design

**Purpose**: Handle all networking and API communication with proper concurrency patterns

**‚úÖ DO:**
- Use protocols for dependency injection and testing
- Make HTTP requests to backend
- Handle request/response serialization
- Manage authentication headers
- Implement retry logic
- Handle network errors
- Use actors for shared mutable state

**‚ùå DON'T:**
- Contain business logic
- Manage UI state
- Transform data for UI (return raw API responses)
- Store credentials directly (use secure storage)

### 4. Models (Codable) - Data Contracts

**Purpose**: Define data structures that match backend API schemas

**‚úÖ DO:**
- Mirror backend Pydantic schemas exactly
- Use Codable for JSON serialization
- Include proper property names (snake_case ‚Üí camelCase)
- Add computed properties for UI convenience

**‚ùå DON'T:**
- Include business logic
- Store state or behavior
- Contain networking code

## üîÑ Data Flow Pattern

The data should flow in a unidirectional pattern:

```
User Interaction ‚Üí View ‚Üí ViewModel ‚Üí Service ‚Üí API
                            ‚Üë                    ‚Üì
                            ‚îî‚îÄ‚îÄ ‚Üê Transform ‚Üê Response
```

## üö® Architecture Mandatory Considerations

### ‚ùå Common Anti-Patterns

1. ‚ùå DON'T: View making API calls
2. ‚ùå DON'T: Service containing business logic
3. ‚ùå DON'T: Model with networking

### ‚úÖ Correct Architecture

1. ‚úÖ GOOD: View delegates to ViewModel with Swift 6 @Observable
2. ‚úÖ GOOD: ViewModel contains business logic with @Observable
3. ‚úÖ GOOD: Protocol-based service with proper concurrency
4. ‚úÖ GOOD: Model is pure data

## Specific Guidelines

### State Management

1. ‚úÖ GOOD: Proper state management with Swift 6 @Observable
2. ‚úÖ GOOD: Use modern Swift async/await
3. ‚úÖ GOOD: Moderns Swift 6 standards only

### Navigation Patterns

1. ‚úÖ GOOD: Only use the custom AppRouter implementation `MoneyApp/Core/Navigation/AppRouter.swift`


## üîÑ Adding New Features

### Step-by-Step Process

1. **Create Feature Directory Structure**
```bash
mkdir -p MoneyApp/Features/NewFeature/{Views,ViewModels,Models,Services}
```

2. **Define Models** (API contracts first)
```swift
// Models/NewFeatureRequest.swift
struct NewFeatureRequest: Codable {
    let parameter: String
}

// Models/NewFeatureResponse.swift
struct NewFeatureResponse: Codable {
    let id: Int
    let result: String
}
```

3. **Create Service** (API integration)
```swift
// Services/NewFeatureService.swift
protocol NewFeatureServiceProtocol: Sendable {
    func performAction(_ request: NewFeatureRequest) async throws -> NewFeatureResponse
}

actor NewFeatureService: NewFeatureServiceProtocol {
    private let apiClient: APIClientProtocol
    
    init(apiClient: APIClientProtocol = APIClient.shared) {
        self.apiClient = apiClient
    }
    
    func performAction(_ request: NewFeatureRequest) async throws -> NewFeatureResponse {
        return try await apiClient.post("/api/new-feature", body: request)
    }
}
```

4. **Implement ViewModel** (Business logic)
```swift
// ViewModels/NewFeatureViewModel.swift
@Observable
@MainActor
class NewFeatureViewModel {
    var isLoading = false
    var result: String?
    var errorMessage = ""
    
    private let service: NewFeatureServiceProtocol
    
    init(service: NewFeatureServiceProtocol = NewFeatureService()) {
        self.service = service
    }
    
    func performAction(parameter: String) async {
        isLoading = true
        do {
            let request = NewFeatureRequest(parameter: parameter)
            let response = try await service.performAction(request)
            result = response.result
        } catch {
            errorMessage = error.localizedDescription
        }
        isLoading = false
    }
}
```

5. **Create View** (UI)
```swift
// Views/NewFeatureView.swift
struct NewFeatureView: View {
    @State private var viewModel = NewFeatureViewModel()
    @State private var inputParameter = ""
    
    var body: some View {
        VStack(spacing: 20) {
            TextField("Enter parameter", text: $inputParameter)
                .textFieldStyle(.roundedBorder)
            
            Button("Perform Action") {
                Task { await viewModel.performAction(parameter: inputParameter) }
            }
            .disabled(viewModel.isLoading)
            
            if viewModel.isLoading {
                ProgressView()
            }
            
            if let result = viewModel.result {
                Text("Result: \(result)")
            }
        }
        .padding()
        .alert("Error", isPresented: .constant(!viewModel.errorMessage.isEmpty)) {
            Button("OK") { viewModel.errorMessage = "" }
        } message: {
            Text(viewModel.errorMessage)
        }
    }
}
```

6. **Build Project** (Verify error and warning free)
```bash
# Essential commands after EVERY Swift file change:
# 1. Build project
xcodebuild -project MoneyApp.xcodeproj -scheme MoneyApp -destination 'platform=iOS Simulator,name=iPhone 16' build
# Must see: Build Succeeded!!!
```

## üéØ Architecture Benefits

This architecture provides:

- **üîß Maintainability**: Clear separation makes code easy to modify
- **üß™ Testability**: Each layer can be tested independently
- **‚ôªÔ∏è Reusability**: Services and models can be shared across features
- **üé™ Consistency**: Standardized patterns across all features
- **üöÄ Scalability**: Add new features without affecting existing ones
- **üîÑ Backend Alignment**: Structure mirrors backend for easier integration

## üìö Quick Reference Checklist

**MANDATORY** Before moving on, verify:

- [ ] Code is organized by feature, not technical layer
- [ ] Views only contain SwiftUI UI code
- [ ] ViewModels use @Observable and handle all business logic
- [ ] Services use actors and protocols for proper concurrency
- [ ] Models are pure Codable data structures
- [ ] No direct API calls in Views
- [ ] Proper async/await usage with Sendable protocols
- [ ] @MainActor on ViewModels
- [ ] @State for ViewModel ownership (not @StateObject)
- [ ] Protocol-based dependency injection for services
- [ ] Actors for shared mutable state in services